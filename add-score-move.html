<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>Document</title>
<style>
*{
	margin:0;
	padding:0;
}
.container{
	width:400px;
	height:400px;
	margin:0 auto;
	border:1px solid #bcbcbc;
}
.box{
	border:1px solid #bcbcbc;
	position:relative;
	margin:310px auto auto auto;
	width:380px;
	height:60px;
}
.innerbox{
	width:0px;/*宽度0 - 380px*/
	height:60px;
	background:#00ccff;
}
#content{
	padding:0 3px;
	position:absolute;
	width:380px;
	height:60px;
	left:0;
	top:0;
}
li{
	list-style:none;
	line-height:60px;
	height:60px;
	padding:0 5px;
	position:absolute;
	top:0;
	left:0;
}
</style>
</head>
<script src="myjs.js"></script>
<script>
window.onload=function(){
	//样式初始化
	var aUl=document.getElementById("content");
	var aLi=aUl.getElementsByTagName("li");
	//alert(aLi.length);
	for (var i=0;i<aLi.length ;i++ )
	{
		aLi[i].style.left=50*i+"px";
	}

	var blueDiv=document.getElementById("innerbox");
	var timer=null;

	//点击以后
	document.onclick=function(){
		//重复点击 每次点击的时候 蓝色块为蓝色可见
		blueDiv.style.opacity=1; 
		blueDiv.style.filter='alpha(opacity:'+100+')';

		//蓝色块变宽
		doMove ( blueDiv, "width", 10, 380,function(){
			changeOpacity(blueDiv,0,function(){
				blueDiv.style.width=0+"px";//每次运动结束 宽度设置为0 就可以重复点击了
			});
		}) ;
		//每个li上移 同时变化透明度
		doMove ( aLi[0], "top", 10,-300,function(){
			aLi[0].style.top=0;
			aLi[0].style.opacity=1; 
			aLi[0].style.filter='alpha(opacity:'+100+')'; 
		}) ;
		//changeOpacity(aLi[0],0);//如果同时给一个对象开2个定时器 那么下面的定时器就会清除掉上面的定时器，无法实现1个对象同时开2个定时器而互不影响
		//obj.timer.timer1 如何把定时器区别开来 ？？？
	
	};

	//////////////////////////////////////////////////////
//获取属性值函数
//说明 1 不可以获取复合样式的值。例如不要获取background的值 每个浏览器都不同 有兼容性问题。可以获取backgroundColor的值；2 获取的值不可以拿来做判断；3 获取的宽或高均不包含边框和padding 只是width or height的值；4 属性值书写的时候不要有空格;5 不要获取未设置后的样式（不兼容）
function getStyle(obj,attr){
	return obj.currentStyle?obj.currentStyle[attr]:getComputedStyle(obj,"FOR FF4.0")[attr];
}

//运动函数封装 leo domove
function doMove ( obj, attr, dir, target, endFn ) {
	dir = parseInt(getStyle( obj, attr )) < target ? dir : -dir;
	clearInterval( obj.timer );
	obj.timer = setInterval(function () {
		var speed = parseInt(getStyle( obj, attr )) + dir;			// 步长
		
		if ( speed > target && dir > 0 ||  speed < target && dir < 0  ) {//刚刚跑过目标点 就马上拉回来
			//这样判断实际上是每次可能超过目标点后再拉回来 。用绝对值方法会好一些。比如步长是3 当从90-93 -96-99走到99的时候 仍然继续 但是此时步长变为目标点100到99差的绝对值 这样就不存在偏离目标点再退回的情况（也许会是bug）
			speed = target;
		}
		
		obj.style[attr] = speed + 'px';
		
		if ( speed == target ) {
			clearInterval( obj.timer );
			/*
			if ( endFn ) {
				endFn();
			}
			*/
			endFn && endFn();
		}
		
	}, 30);
}
//运动函数封装 leo domove 结束

//抖动函数封装
function shake ( obj, attr, endFn ) {
	var pos = parseInt( getStyle(obj, attr) );//有bug 每次重开定时器回不到原点 解决办法：
	//在函数体外把原始的attr值储存起来 每次点击 都把原始值付给该对象。比如是left 
	//和top方向抖动 首先把初始的left和top值储存起来 然后每次点击事件发生 都把原始的
	//left和top值付给被点击对象
	var arr = [];			// 20, -20, 18, -18 ..... 0
	var num = 0;
	var timer = null;
		
	for ( var i=20; i>0; i-=2 ) {
		arr.push( i, -i );
	}
	arr.push(0);
		
	clearInterval( obj.shake );
	obj.shake = setInterval(function (){
		obj.style[attr] = pos + arr[num] + 'px';
		num++;
		if ( num === arr.length ) {
			clearInterval( obj.shake );
			endFn && endFn();
		}
	}, 50);
}
//抖动函数封装结束

//透明度函数
function changeOpacity(obj,target,endFn){ 
	var opa; 
	var speed; 
	if(obj.currentStyle){ 
		  //判断浏览器类型，此类型为IE浏览器，即使IE不支持opacity属性，但是仍然可以获取值 
		 opa = obj.currentStyle['opacity']*100; 
	} 
	else{//其他浏览器 
		opa = getComputedStyle(obj,false)['opacity']*100; 
	} 
	//透明度每次变化的值（步长），根据目标值和当前值的差来决定步长的正负 
	target-opa>=0?speed=10:speed=-10; 
	clearInterval(obj.timer); 
	obj.timer = setInterval(function (){ 
	//目标值和当前值差值的绝对值大于等于步长的绝对值，设置透明度为当前值加步长 
	if(Math.abs(target-opa)>=Math.abs(speed)){ 
		obj.style.opacity=(opa+speed)/100; 
		obj.style.filter='alpha(opacity:'+(opa+speed)+')'; 
	} 
	//目标值和当前值差值的绝对值小于步长的绝对值，剩余的距离一步到位， 
	//设置透明度直接为目标值，同时清除定时器 
	else{ 
	   obj.style.opacity=target/100; 
	   obj.style.filter='alpha(opacity:'+target+')'; 
	   clearInterval(obj.timer); 
	   endFn && endFn();
	} 
	//直接对透明度参数进行加步长的运算，避免每次都要获取当前透明度 
	opa=opa+speed; 
	},30); 
} 
//////////////////////////////////////////////////////

};
</script>
<body>
	<div class="container">
		<div class="box">
			<div class="innerbox" id="innerbox"></div>
			<ul id="content">
					<li>+1</li>
					<li>+1</li>
					<li>+1</li>
					<li>+1</li>
					<li>+1</li>
					<li>+1</li>
					<li>+1</li>
					<li>+1</li>
			</ul>
		</div>
	</div>
</body>
</html>
